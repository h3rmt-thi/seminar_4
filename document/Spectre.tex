\section{Spectre}
\label{sec:spectre}

Spectre wurde von verschiedenen Forschenden entdeckt (Project~Zero und Paul C.~Kocher + weitere) und am 3.~Januar~2018 veröffentlicht~\cite{kocher2018spectre}.
Hardwarehersteller wie Intel, AMD usw.~sowie Softwarehersteller wie Microsoft wurden bereits am 1.~Juni 2017 im Vorfeld informiert, um die Lücke bereits im Voraus durch Softwareupdates zu schließen. \\
Spectre ist ein Angriff, der Daten über einen Cache-Side-Channel ausliest.
Bei Side-Channels handelt es sich um indirekte Informationen, die über ein System gewonnen werden können, wie beispielsweise der Stromverbrauch der CPU, Elektromagnetische Strahlung, Zeitmessungen oder sogar Geräusche.
Spectre analysiert die Zugriffszeiten auf Daten, um zu bestimmen, ob diese aus dem Arbeitsspeicher geladen werden mussten (Zugriff dauert mehrere 100 Zyklen) oder durch vorherige Zugriffe bereits in den Cache geladen wurden (Zugriff dauert <10 Zyklen).
Um diese Daten in den Cache zu laden, nutzt Spectre die spekulative Ausführung von Befehlen, um Daten zu laden, die normalerweise nicht geladen werden dürften.
Die spekulative Ausführung erlaubt das Laden dieser Daten, da die Überprüfung, ob der Zugriff auf diese Daten überhaupt legitim ist, erst zur \enquote{tatsächlichen} und nicht spekulativen Ausführung erfolgt.

\subsection{Vorgehensweise \cite{kocher2018spectre}}
\label{subsec:spectre_vorgehensweise}
\begin{itemize}
	\item \textbf{1. Schritt:} 2 Arrays mit verschiedenen Größen (\texttt{array1: 16 Elemente, array2: 265 * 512 Elemente}) werden allokiert, die später für spekulative Zugriffe und Cache-Messungen verwendet werden.
	\item \textbf{2. Schritt:} Es wird berechnet, wie weit der auszulesende Speicherbereich vom Anfang von \texttt{array1} entfernt ist.
	      Dieser Abstand wird benötigt, um einen Index zu bestimmen, der beim Zugriff auf \texttt{array1} tatsächlich auf den Zielbereich verweist (Im nachfolgenden Beispiel \texttt{31000}).
\end{itemize}

\noindent
\begin{minipage}{0.58\textwidth}
	\begin{itemize}
		\item \textbf{3. Schritt:} Spectre nutzt folgenden Code, um den Cache zu trainieren: \\
		      \phantomsection\label{itm:spectre_step3_code}
		      \texttt{array2[array1[x] * 512]} \\
		      Dieser Aufruf nutzt den Wert, der sich in array1 an der Stelle x befindet (multipliziert mit 512), um auf einen Wert in array2 zuzugreifen.
		      Der Wert, welcher sich tatsächlich in array2 befindet, ist hier irrelevant.
		      Ein solcher Aufruf mit dem Wert \texttt{x=2} hätte zur Folge, dass der Wert an der Stelle \texttt{array2[array[2] * 512]} in den Cache geladen wird.
		      Befindet sich an der Stelle \texttt{array1[2]} der Wert \texttt{42}, wird so der Teil des \texttt{arrays2} and der Stelle \texttt{array2[42 * 512]} in den Cache geladen.
	\end{itemize}
\end{minipage}
\hfill
\begin{minipage}{0.4\textwidth}
	\centering
	\includegraphics[width=\linewidth]{Attack-2}
\end{minipage}


\begin{itemize}
	\item \textbf{4. Schritt:}\phantomsection\label{itm:spectre_step4} Die oben genannte Zeile wird mehrmals in einer Schleife ausgeführt, um den Branch Predictor zu trainieren.
	      Hierbei werden \texttt{x} Werte verwendet, die innerhalb des \texttt{arrays1} liegen.
	      Dies lässt die CPU vermuten, dass zukünftige Durchläufe der Schleife ebenfalls diesen Aufruf ausführen werden, was wiederum zur Folge hat, dass für zukünftige \texttt{x} Werte der Aufruf bereits spekulativ ausgeführt wird.
	\item \textbf{5. Schritt:} Der Wert \texttt{x} wird auf einen Wert gesetzt, der sich nicht im \texttt{array1} befindet.
	      Dieser Wert entspricht dem Abstand zwischen dem \texttt{array1} und einem Bereich im Arbeitsspeicher, der versucht wird mit diesem Exploit auszulesen.
	      Die CPU führt durch das vorherige Training den spekulativen Zugriff auf \texttt{array1} aus, obwohl der Wert \texttt{x} nicht im \texttt{array1} vorhanden ist.
	      Beispielsweise könnte \texttt{x=31000} gesetzt werden, was zur Folge hat, dass der Wert, der sich in \texttt{array1} an der Stelle \texttt{31000} befinden würde, geladen wird (In C entspricht der Zugriff mit \texttt{array[x]} der Startadresse von \texttt{array} + \texttt{x} * Größe des Datentyps).
	      Da \texttt{array1} aber nur 16 Elemente lang ist, befinden sich an dieser Stelle andere Werte (die wir spekulativ auslesen wollen).
	      Der Wert, welcher sich an dieser Stelle befindet und sich im Bereich von 0 bis 255 befindet, wird nun mit dem Wert \texttt{512} multipliziert und genutzt, um auf ein Element in \texttt{array2} zuzugreifen.
	      Dieser Zugriff hat für uns zwar keinen direkten Nutzen, da sich in \texttt{array2} keine interessanten Werte befinden, führt aber dazu, dass der Teil dieses Arrays, auf den soeben zugegriffen wurde, in den Cache geladen wird.
	      (Die Abstände von 512 Bytes sind so groß gewählt und zu verhindern, dass mehrere Teile des \texttt{array2} in den Cache geladen werden.)
	\item \textbf{6. Schritt:} Durch eine spezielle Bedingung, welche prüft, ob der \texttt{x} innerhalb des \texttt{arrays1} liegt, wird verhindert, dass der Zugriff auf \texttt{array1[x]} tatsächlich ausgeführt wird, um einen Segmentation Fault zu verhindern.
	      Die spekulative Ausführung hat diese Bedingung auch für \texttt{x} Werte außerhalb des \texttt{array1} ignoriert, da sie in vergangenen Durchläufen bereits als \enquote{wahr} bewertet wurde.
	      Dies sorgt dafür, dass die ausgeführt spekulative Ausführung des Zugriffs auf \texttt{array1} verworfen wird und es somit auch nicht mehr möglich ist, den Wert, der sich an dieser Stelle befunden hat, im weiteren Verlauf des Programms zu verwenden.
	\item \textbf{7. Schritt:} Nun werden alle 255 möglichen Werte, die sich an der Stelle \texttt{array1[x]} befinden könnten, nacheinander getestet.
	      Hierfür wird in einer Schleife gemessen wie lange ein Zugriff auf das Element \texttt{array2[i * 512]} dauert.
	      Falls sich an der Stelle \texttt{array1[x]} z.B.~der Wert \texttt{4} befunden hat, würde dies bedeuten, dass die spekulative Ausführung das Element \texttt{array2[4 * 512]} in den Cache geladen hat.
	      Wird nun gemessen, dass der Zugriff auf \texttt{array2[4 * 512]} deutlich schneller ist als der Zugriff auf andere Elemente wie \texttt{array2[0 * 512]} oder \texttt{array2[5 * 512]} so kann davon ausgegangen werden, dass sich an der Stelle \texttt{array1[x]} der Wert \texttt{4} befunden hat.
	\item \textbf{8. Schritt:} Der soeben ermittelte Wert wird gespeichert und der \texttt{x} Wert um 255 Bits erhöht.
	      Dadurch wird der nächste Durchlauf die nächsten 8 Bytes des Zielbereiches auslesen.
	      Schlussendlich wird zu \hyperref[itm:spectre_step4]{\underline{Schritt 4}} zurückgekehrt.
\end{itemize}

\subsection{Spectre-V2}
\label{subsec:spectre_spectre-v2}

Die oben beschriebene Variante von Spectre ist nur eine von vielen verschiedenen Varianten und Weiterentwicklungen.
Die bekannteste Weiterentwicklung ist Spectre-V2~\cite{spec_v2}, die sich gegen den Branch Predictor richtet.
Seit der ersten Version von Spectre-V2 im Jahr 2018 (SpectreBTB) entstehen kontinuierlich neue Varianten und Abwandlungen, wie z.B. \textbf{Retbleed}~\cite{spec_v2_retbleed} aus dem Jahr 2022 oder \textbf{Training Solo}~\cite{training_solo} aus dem Jahr 2025. \\
Wie auch bei Spectre-V1 wird spekulativ Code ausgeführt, welcher daraufhin Daten in den Cache lädt die über Timing-Angriffe ausgelesen werden können.
Anstatt aber rein auf speculative Ausführung im eigenen Programm zu setzen, wird bei SpectreBTB ausgenutzt, dass der Branch Prediction Buffer (BPB) zwischen Prozessen geteilt wird.
Dieser Buffer beinhaltet Daten, die für die Vorhersage von Branches verwendet und während der Zuführung von Programmen gesammelt werden.
Wenn die CPU im Programmablauf auf eine Branch trifft, bei der noch nicht klar ist, wohin diese springen wird, wird der BTB verwendet, um den wahrscheinlichsten Sprung zu bestimmen und die spekulative Ausführung zu ermöglichen. \\
Um einen Angriff auszuführen, trainieren wird in unserem Programm den BPB so, dass er in der Zukunft Branches vorhersagt, die von uns für Vorteil sind.
Wenn die CPU nun ein anderes Programm ausführt, in dem sich eine Branch befindet, deren Sprungziel unbekannt ist, wird der BTB verwendet, um den wahrscheinlichsten Sprung zu bestimmen.
Durch unser Training wird der Branch Predictor jetzt einen Sprung vorhersagen, der im Programm so tatsächlich nie ausgeführt worden wäre.
Dies ermöglicht es uns, wenn auch nur spekulativ, den Verlauf des Programmes zu ändern. \\
Um jetzt Daten in den Cache laden zu lassen, trainieren wir BPB mit der Adresse eines bestimmten Gadgets.
Dieses Gadget ist ein Codeabschnitt, der in diesem Programm oder geladenen Bibliotheken vorhanden ist und in unserem Fall dem Code aus \hyperref[itm:spectre_step3_code]{\underline{Schritt 3}} der Spectre-V1 Attacke ähnelt.
Schlussendlich werden vom angreifenden Programm wieder Zeitmessungen durchgeführt, um den Wert zu ermitteln, der soeben in den Cache geladen wurde.

\subsection{Gegenmaßnahmen}
\label{subsec:spectre_gegenmassnahmen}

Gegenmaßnahmen gegen Spectre-V2 wurden an verschiedenen Stellen implementiert.
Einerseits wurden auf Softwareseite verschiedene Patches veröffentlicht.
So wurden im Linux Kernel verschiedene Maßnahmen implementiert, um zu verhindern, dass verschiedene sensitive Funktionen spekulativ ausgeführt werden können~\cite{linux_nospec}.
Dies verhindert, dass der Branch Predictor durch Manipulation innerhalb des Kernels durch spekulative Ausführung Daten leaken kann.
So kann die Funktion \texttt{array\_index\_nospec} genutzt werden, um trotz spekulativer Ausführung Zugriffe auf die Bereiche von arrays zu begrenzen.
Diese muss allerdings manuell in den Code eingefügt werden, um sicherzustellen, dass dieser Code nicht durch manipulation spekulativ ungewollte Daten lädt.
\\
Andererseits wurden auch verschiedene Maßnahmen in den Browsern implementiert, um zu verhindern, dass Spectre-V2 Angriffe über JavaScript ausgeführt werden können.
So wurde in Firefox und Webkit die Genauigkeit von Zeitmessungen reduziert, um zu verhindern, dass Angreifer den Cache-Zugriff über Timing-Angriffe auslesen können (\texttt{performance.now()} wurde auf Genauigkeit von 20µs reduziert~\cite{luke_wagner_2018}).
Chrome hingegen hat die Sandbox-Funktionalität erweitert und ermöglicht es Websites in separaten Prozessen laufen zu lassen
~\cite{heise_2018_spec}.\\
Des Weiteren wurden von verschiedenen Hardwareherstellern wie Intel und AMD Updates für den Microcode veröffentlicht.
Im Fall von Intel wurde \textbf{IBRS} (Indirection Branch Restricted Speculation~\cite{intel_1}), \textbf{IBPB} (Indirect Branch Predictor Barrier~\cite{intel_2}) und \textbf{STIBP} (Single Thread Indirect Branch Predictors~\cite{intel_3}) implementiert.
Diese Maßnahmen verhindern, dass der Branch Predictor zwischen logischen Prozessoren der CPU, oder Prozessen unterschiedlicher Privilegien geteilt wird.
Dass diese Gegenmaßnahmen nicht immer ausreichen, zeigt \textbf{Training Solo}~\cite{training_solo}, welches diese Schutzmaßnahmen umgeht, indem das Trainieren des BTB nicht im einen Programm erfolgt, sondern direkt im Kernel.
Somit sind Schutzmaßnahmen wie \textit{IBRS} nicht mehr wirksam, da das Training des BTB von einem privilegierten Prozess ausgeführt wird.
Intel hat hierfür bereits über Microcode-Updates reagiert und die Instruktion \textit{IBHF}~\cite{darkcrizt_2025} hinzugefügt.